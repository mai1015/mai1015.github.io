---
layout: post
title: Keycloak Docker setup and reverse proxy from nginx
category: Development
tags: [Linux, Development, Docker]
comments: true
---
Keycloak is an open source Identity and Access Management software that is part of Red Hat project. It provided OAuth and SSO support for your application and software. It is easy to setup, but you need to download the dependency and setup in confiugration file. We can use docker to set this up easily.

From [github](https://github.com/jboss-dockerfiles/keycloak) repository, we can find the information about keycloak docker. One of the simple setup is `docker run -e KEYCLOAK_USER=<USERNAME> -e KEYCLOAK_PASSWORD=<PASSWORD> jboss/keycloak`. Then it is going up and running. We can have a database connection when we set `DB_VENDOR` environment variable. There are sample setup for keycloak with mysql. It is pretty easy with docker.

However, I do not need multiple mysql instance running. I prefer single mysql service at my localhost. So, we need to connect host mysql within the continer. We have to locate the host ip address from container. Docker used to proivde `host.docker.internal` to resolve host ip address. However, it resolve to nothing in Ubuntu docker. I found a simple work around from [here](https://stackoverflow.com/questions/24319662/from-inside-of-a-docker-container-how-do-i-connect-to-the-localhost-of-the-mach).

## SETUP
Basically, it set the network mode to `host`, so localhost can access the actual machine. so I set it with `docker-compose` with `network_mode: host`. So the sample compose setup will look like this. With the file, we can set the database clear. The file is generated with `jhipster`, and I modify it to connect it to the database.

```yaml
version: '2'
services:
  keycloak:
    image: jboss/keycloak:5.0.0
    network_mode: host
    command: ["-b", "0.0.0.0", "-Dkeycloak.migration.action=import", "-Dkeycloak.migration.provider=dir", "-Dkeycloak.migration.dir=/opt/jboss/keycloak/realm-config", "-Dkeycloak.migration.strategy=OVERWRITE_EXISTING", "-Djboss.socket.binding.port-offset=1000"]
    volumes:
      - ./realm-config:/opt/jboss/keycloak/realm-config
    environment:
      - PROXY_ADDRESS_FORWARDING=true
      - KEYCLOAK_USER=admin
      - KEYCLOAK_PASSWORD=admin
      - DB_VENDOR=mariadb
      - DB_DATABASE=keycloak
      - DB_USER=keycloak
      - DB_PASSWORD=passwd
    ports:
      - 9080:9080
      - 9443:9443
      - 10990:10990
```
It is important to add `PROXY_ADDRESS_FORWARDING=true` since we want to working with reverse proxy nginx.

We can then run the file with `docker-compose -f keycloak.yml up`. However, it does not work because of the message `Failed to start service org.wildfly.network.interface.private`. There is nothing I can find on the internet, but it works fine on my other computer. It should be a problem with docker in Ubuntu. So, I have use another way.

## MYSQL
We have to know the ip address of the host in the container. So, I found this command `ip route show | awk '/default/ {print $3}'`. It will show the host ip in the docker. We can simply do it like `docker run --rm alpine ip route show | awk '/default/ {print $3}'`, and I will see the ip. For me, the ip is `172.17.0.1`. So I add `DB_ADDR=172.17.0.1` into the environment. And let mysql listen to ip `0.0.0.0` then the container is allow to connected to the serivce.

One more thing is the mysql user. We can add a user with remote access, but it is not safe. So I add the user in mysql with sql command.

```sql
CREATE USER 'keycloak'@'172.*' IDENTIFIED BY 'password';
GRANT ALL PRIVILEGES ON `keycloak`.* TO 'keycloak'@'172.*';
FLUSH PRIVILEGES;
```

or we can simply do `GRANT ALL PRIVILEGES ON `keycloak`.* To 'keycloak'@'172.*' IDENTIFIED BY 'password';`. They both work well with `mariadb-10.3.14`.

## NGINX
We want to proxy it with `nginx` so we do not need to convert certificate. It is eaiser to replace and do not stop the keycloak service. So, I obtian certificate with `certbot` and activate it with nginx configurate like this.

<details><summary>nginx file</summary>
<p>
```nginx
server {
    listen 80;
    listen [::]:80;
    server_name example.com;

    location / {
        rewrite ^ https://example.com$request_uri? permanent;
    }
}

server {
    server_name example.com; # managed by Certbot

    access_log /var/log/nginx/ide.mai1015.com-access.log;
    error_log /var/log/nginx/ide.mai1015.com-error.log;

    # SSL configuration

    listen 443 ssl http2;
    # listen [::]:443 ssl http2 ipv6only=on;

    # Note: You should disable gzip for SSL traffic.
    # See: https://bugs.debian.org/773332
    #
    # Read up on ssl_ciphers to ensure a secure configuration.
    # See: https://bugs.debian.org/765782
    #
    # Self signed certs generated by the ssl-cert package
    # Don't use them in a production server!
    #
    # include snippets/snakeoil.conf;

    # Add index.php to the list if you are using PHP
    index index.html index.htm index.nginx-debian.html;

    location / {
        proxy_pass http://localhost:9080;
        proxy_read_timeout 90;

        # proxy header
        proxy_set_header X-Real-IP $remote_addr;
        proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
        proxy_set_header X-Scheme $scheme;
        proxy_set_header X-Forwarded-Proto $scheme;
        proxy_set_header Host $host;

        # ws
        proxy_http_version 1.1;
        #proxy_set_header Upgrade $http_upgrade;
        #proxy_set_header Connection 'Upgrade';

        # proxy_cache_bypass $http_upgrade;

        #proxy_redirect http://localhost:9080 https://example.com;
    }

    ssl_certificate /etc/letsencrypt/live/example.com/fullchain.pem; # managed by Certbot
    ssl_certificate_key /etc/letsencrypt/live/example.com/privkey.pem; # managed by Certbot
    # include /etc/letsencrypt/options-ssl-nginx.conf; # managed by Certbot
    # ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem; # managed by Certbot
}
```
</p>
</details>

So those configurates are important to allow keycloak to work correctly. Without `Host` header will break the `redirect_url`.
```nginx
    proxy_set_header X-Real-IP $remote_addr;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Scheme $scheme;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_set_header Host $host;
```

So we have a fully configurated keycloak working behind reverse proxy nginx. 